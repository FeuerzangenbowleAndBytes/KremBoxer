import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import json
import shutil
import scipy.optimize as so
import kremboxer.utils.greybody_utils as gbu


def fit_received_bandpass_energy(f, ts):
    """

    Parameters
    ----------
    f
    ts

    Returns
    -------

    """

    lams = f[:,0]*10**(-6)
    dlam = lams[1] - lams[0]
    wd = np.zeros_like(ts)

    for i in range(0, len(ts)):
        w_lam = gbu.GB_lambda(lams, ts[i])
        wd[i] = np.sum(w_lam*f[:,1])*dlam

    (A, N), pcov = so.curve_fit(gbu.planck_model, ts, wd)
    return (A, N, wd)


def compute_dualband_calibration(cal_params: dict):
    """
    Computes model for retrieving radiance measurements from voltage readings generated by longwave and midwave sensors
    on the dualband devices

    Parameters
    ----------
    cal_params: dict
        asdfa

    Returns
    -------

    """

    print("Computing dualband calibration with parameters: ", cal_params)

    # Grab input calibration data
    cal_input_dir = Path(cal_params["calibration_inputs_folder"])
    LW_bandpass_path = cal_input_dir.joinpath("DC-6073_W1_8-14Si.csv")
    MW_bandpass_path = cal_input_dir.joinpath("DC-6216_u1_Saph_longwave.csv")
    cal_input_path = cal_input_dir.joinpath("unit11_calibration_data.csv")
    temp_cal_input_path = cal_input_dir.joinpath("temperature_sensor_calibration.csv")
    v_top = 3300
    r_top = 100000

    # Where to store output calibration model
    cal_id = cal_params["calibration_id"]
    cal_output_dir = Path(cal_params["calibration_outputs_folder"]).joinpath(cal_id)
    cal_output_dir.mkdir(exist_ok=True, parents=True)

    # Copy input data into output data so that we can easily match calibration models with input data
    shutil.copy(LW_bandpass_path, cal_output_dir.joinpath(LW_bandpass_path.name))
    LW_bandpass_path = cal_output_dir.joinpath(LW_bandpass_path.name)
    shutil.copy(MW_bandpass_path, cal_output_dir.joinpath(MW_bandpass_path.name))
    MW_bandpass_path = cal_output_dir.joinpath(MW_bandpass_path.name)
    shutil.copy(cal_input_path, cal_output_dir.joinpath(cal_input_path.name))
    cal_input_path = cal_output_dir.joinpath(cal_input_path.name)
    shutil.copy(temp_cal_input_path, cal_output_dir.joinpath(temp_cal_input_path.name))
    temp_cal_input_path = cal_output_dir.joinpath(temp_cal_input_path.name)

    # Load the bandpass functions for the two sensors
    f_mw = np.loadtxt(MW_bandpass_path, delimiter=',', skiprows=1, usecols=[0, 1])
    f_lw = np.loadtxt(LW_bandpass_path, delimiter=',', skiprows=1, usecols=[0, 1])

    # Load the blackbody calibration data
    blackbody_cal_data = np.loadtxt(cal_input_path, delimiter=",", skiprows=1)

    # Convert the temperature sensor mV data into resistance, using known voltage divider characteristics
    t_mV = blackbody_cal_data[:, 1]
    v_top = cal_params["v_top"]  # voltage at the top of divider in mV
    r_top = cal_params["r_top"]  # 100kOhm resistor in voltage divider
    t_resist = t_mV * r_top / (v_top - t_mV)  # Convert mV reading into resistance of temperature sensor

    # Load actual temperatures and detector signals from calibration data
    t_actual = blackbody_cal_data[:, 0]
    v_lw = blackbody_cal_data[:, 2]
    v_mw = blackbody_cal_data[:, 3]

    # Compute the temperature of the detector from its resistance
    t_cal_data = np.loadtxt(temp_cal_input_path, skiprows=1, delimiter=",", usecols=[0, 1, 2])
    t_cal_data = np.flip(t_cal_data, 0)
    t_temp = gbu.detector_temperature_lookup(R=t_resist, temp_cal_data=t_cal_data)

    # Fit a polynomial for the blackbody energy received by each sensor, W~A*T**N
    # LW
    (A_MW, N_MW, wd_mw) = fit_received_bandpass_energy(f_mw, t_actual)
    (A_LW, N_LW, wd_lw) = fit_received_bandpass_energy(f_lw, t_actual)

    # Now fit the detector model with the calibration data to get G and AL
    # Note that since the detector temp barely changes during calibration, we set it to a constant 300 K during this fit
    (G_LW, AL_LW), pcov_LW = so.curve_fit(lambda T, G, AL: gbu.detector_model(T, G, AL, 300, A_LW, N_LW),
                                          t_actual, v_lw)
    # TODO: Left out the 0 at the beginning of MW data, caused optimizer to crash, handle better
    (G_MW, AL_MW), pcov_MW = so.curve_fit(lambda T, G, AL: gbu.detector_model(T, G, AL, 300, A_MW, N_MW),
                                          t_actual[1:], v_mw[1:], maxfev=1000)
    print("Calibration values:")
    print("LW: N_LW=", N_LW, ", A_LW=", A_LW, ", G_LW=", G_LW, ", AL_LW=", AL_LW)
    print("MW: N_MW=", N_MW, ", A_MW=", A_MW, ", G_MW=", G_MW, ", AL_MW=", AL_MW)



