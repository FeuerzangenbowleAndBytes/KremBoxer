import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import json
import shutil
import scipy.optimize as so
import scipy.constants as sc
import kremboxer.utils.greybody_utils as gbu
import kremboxer.utils.common_utils as kcu
import datetime
import pandas as pd


def compute_ufm_calibration(cal_params: dict):
    """
    Computes model for retrieving radiance measurements from voltage readings generated by longwave, midwave, wide
    sensors on the ufm devices

    Parameters
    ----------
    cal_params: dict
        "calibration_inputs_folder": folder containing the below calibration input data
        "LW_bandpass": bandpass for the longwave sensor, path to csv
        "MW_bandpass": bandpass for the midwave sensor, path to csv
        "WIDE_bandpass": bandpass for the wideband sensor, path to csv
        "cal_input": sensor values collected with a blackbody for calibration, path to csv
        "temp_cal_input": lookup table relating temperature to resistance of the temperature sensor inside the device, path to csv
        "v_top": voltage applied across the internal temperature sensor voltage divider
        "r_top": resistance of resistor in internal temperature sensor voltage divider
        "calibration_outputs_folder": folder to store the calibration results

    Returns
    -------
        None, calibration results are saved to file
    """

    print("Computing UFM calibration with parameters: ", cal_params)

    # Grab input calibration data
    cal_input_dir = Path(cal_params["calibration_inputs_folder"])
    bands_dict = cal_params["bands"]
    cal_input_path = cal_input_dir.joinpath(cal_params["cal_input"])
    temp_cal_input_path = cal_input_dir.joinpath(cal_params["temp_cal_input"])
    v_top = cal_params["v_top"]
    r_top = cal_params["r_top"]

    # Where to store output calibration model
    cal_id = cal_params["calibration_id"]
    cal_output_dir = Path(cal_params["calibration_outputs_folder"]).joinpath(cal_id).joinpath("ufm")
    cal_output_dir.mkdir(exist_ok=True, parents=True)

    # Copy input data into output directory so that we can easily match calibration models with input data
    shutil.copy(cal_input_path, cal_output_dir.joinpath(cal_input_path.name))
    cal_input_path = cal_output_dir.joinpath(cal_input_path.name)
    shutil.copy(temp_cal_input_path, cal_output_dir.joinpath(temp_cal_input_path.name))
    temp_cal_input_path = cal_output_dir.joinpath(temp_cal_input_path.name)

    # Load parameters needed to convert temperature sensor mV readings into resistance, using known voltage divider characteristics
    v_top = cal_params["v_top"]  # voltage at the top of divider in mV
    r_top = cal_params["r_top"]  # 100kOhm resistor in voltage divider
    t_cal_data = np.loadtxt(temp_cal_input_path, skiprows=1, delimiter=",", usecols=[0, 1, 2])
    t_cal_data = np.flip(t_cal_data, 0)

    # Load the blackbody calibration data and the target temperatures
    blackbody_cal_data_df = pd.read_csv(cal_input_path)
    t_actual = blackbody_cal_data_df["Target T [K]"].to_numpy()

    # Also copy and load bandpass into numpy arrays stored in the band dictionary
    for band, band_data in bands_dict.items():
        bandpass_path = Path(band_data["bandpass"])
        bandpass_copy_path = cal_output_dir.joinpath(bandpass_path.name)
        shutil.copy(bandpass_path, bandpass_copy_path)
        bands_dict[band]["bandpass"] = bandpass_copy_path
        f = np.loadtxt(bands_dict[band]["bandpass"], delimiter=',', skiprows=1, usecols=[0, 1])

        # Load temperature sensor data
        t_sensor_mV = blackbody_cal_data_df[band_data["sensor_temp"]].to_numpy()
        t_sensor_resist = t_sensor_mV * r_top / (
                    v_top - t_sensor_mV)  # Convert mV reading into resistance of temperature sensor
        t_sensor_temp = gbu.detector_temperature_lookup(R=t_sensor_resist, temp_cal_data=t_cal_data)

        # Load the detector signal from the calibration data
        v = blackbody_cal_data_df[band_data["datalog_col"]].to_numpy()

        # Fit a polynomial for the blackbody energy received by each sensor, W~A*T**N
        (A, N, wd) = gbu.fit_received_bandpass_energy(f, t_actual)

        # Now fit the detector model with the calibration data to get G and AL
        G, AL, pcov = kcu.fit_detector_model(t_actual, t_sensor_temp, v, A, N, p0=[band_data["G0"], band_data["AL0"]])

        # Save the fit parameters and sensor data in the band dictionary
        bands_dict[band]["f"] = f
        bands_dict[band]["t_sensor_temp"] = t_sensor_temp
        bands_dict[band]["v"] = v
        bands_dict[band]["A"] = A
        bands_dict[band]["N"] = N
        bands_dict[band]["G"] = G
        bands_dict[band]["AL"] = AL
        bands_dict[band]["wd"] = wd
        bands_dict[band]["W_GB"] = bands_dict[band]["v"] / bands_dict[band]["G"] + bands_dict[band]["AL"] * \
                                   bands_dict[band]["t_sensor_temp"] ** bands_dict[band]["N"]

        # Print the calibration values
        print(f'{band}: N={N}, A={A}, G={G}, AL={AL}')

    ###############################################
    # End of calibration, now see how well the
    # computation of target temp reproduces the
    # known calibration data and make a big plot
    ###############################################
    lams = np.arange(0, 20, 0.05)
    fig, axs = plt.subplots(3, 3, figsize=(12, 15))

    # Plot blackbody curves for the calibration temperatures
    for T in t_actual:
        axs[0, 0].plot(lams, gbu.GB_lambda(lams * 10 ** -6, T), label=f'{T}K')

    # Plot the individual band data
    for band, band_data in bands_dict.items():
        axs[1, 0].plot(band_data["f"][:, 0], band_data["f"][:, 1], label=band)
        plot_col = 1
        if not band_data["type"] == "broad":
            plot_col = 2
        axs[0, plot_col].scatter(t_actual, band_data["wd"],
                                 label=f'{band}, A={band_data["A"]:.3}, N={band_data["N"]:.2f}')
        axs[0, plot_col].plot(t_actual, gbu.planck_model(t_actual, band_data["A"], band_data["N"]), ls='--')
        axs[1, plot_col].scatter(t_actual, band_data["v"],
                                 label=f'{band}, G={band_data["G"]:.3}, AL={band_data["AL"]:.3}')
        axs[1, plot_col].plot(t_actual, gbu.detector_model(t_actual, band_data["G"], band_data["AL"],
                                                           band_data["t_sensor_temp"], band_data["A"],
                                                           band_data["N"]), ls='--')
        axs[0, plot_col].plot(t_actual, band_data["W_GB"], color='grey')
        axs[2, 0].plot(t_actual, band_data["t_sensor_temp"], label=f'{band}')

    # Try to predict target known temperatures, eA, FRP
    ratio_mw_lw = bands_dict["MW"]["W_GB"] / bands_dict["LW"]["W_GB"]
    t_predict_mw_lw = np.zeros_like(t_actual)
    for i in range(0, len(t_actual)):
        t_predict_mw_lw[i] = so.brentq(
            lambda Ts: gbu.GB_ratio_BP(Ts, bands_dict["MW"]["f"], bands_dict["LW"]["f"]) - ratio_mw_lw[i], 300,
            2000)

    axs[2, 1].plot(t_actual, t_predict_mw_lw - t_actual, label="MW/LW")
    axs[2, 2].plot(t_actual, t_predict_mw_lw, label="MW/LW")
    axs[2, 2].plot(t_actual, t_actual, label="Actual")

    # Compute and plot emissivity area product and FRP
    eA_MW = bands_dict["MW"]["W_GB"] / gbu.planck_model(t_predict_mw_lw, bands_dict["MW"]["A"],
                                                        bands_dict["MW"]["N"])
    FRP_MW = eA_MW * sc.Stefan_Boltzmann * t_predict_mw_lw ** 4
    eA_LW = bands_dict["LW"]["W_GB"] / gbu.planck_model(t_predict_mw_lw, bands_dict["LW"]["A"],
                                                        bands_dict["LW"]["N"])
    FRP_LW = eA_LW * sc.Stefan_Boltzmann * t_predict_mw_lw ** 4

    FRP_WIDE = bands_dict["WIDE"]["W_GB"] / bands_dict["WIDE"]["BandpassFraction"]
    # t_predict_wide = np.pow(FRP_WIDE / bands_dict["WIDE"]["A"], 1./bands_dict["WIDE"]["N"])
    # FRP_WIDE_T = sc.Stefan_Boltzmann * t_predict_wide ** 4
    # axs[2, 2].plot(t_actual, t_predict_wide, label="WIDE")

    axs[0, 2].plot(t_actual, eA_MW, label="MW")
    axs[0, 2].plot(t_actual, eA_LW, label="LW")
    axs[0, 2].set_title("Emissivity Area Product")
    axs[0, 2].set_xlabel("Calibration Temp [K]")
    axs[0, 2].set_ylabel("Emissivity*Area")
    axs[0, 2].legend()

    axs[1, 2].plot(t_actual, FRP_MW, label="MW")
    axs[1, 2].plot(t_actual, FRP_LW, label="LW")
    axs[1, 2].plot(t_actual, FRP_WIDE, label="WIDE")
    #axs[1, 2].plot(t_actual, FRP_WIDE_T, label="WIDE, T")
    axs[1, 2].set_title("Fire Radiative Power")
    axs[1, 2].set_xlabel("Calibration Temp [K]")
    axs[1, 2].set_ylabel("FRP [W/m^2]")
    axs[1, 2].legend()

    axs[0, 0].set_title("Planck Radiance at Cal Temps")
    axs[0, 0].set_xlabel("Wavelength [um]")
    axs[0, 0].set_ylabel("Radiance [W/m^2*um]")
    axs[0, 0].legend()
    axs[1, 0].set_title("Bandpasses")
    axs[1, 0].set_xlabel("Wavelength [um]")
    axs[1, 0].set_ylabel("Transmission")
    axs[1, 0].legend()
    axs[0, 1].set_title("Blackbody Irradiance")
    axs[0, 1].set_xlabel("Calibration Temp [K]")
    axs[0, 1].set_ylabel("Irradiance [W/m^2]")
    axs[0, 1].legend()
    axs[1, 1].set_title("Sensor Signal")
    axs[1, 1].set_xlabel("Calibration Temp [K]")
    axs[1, 1].set_ylabel("Voltage [mV]")
    axs[1, 1].legend()
    axs[1, 2].set_title("Fire Radiative Power")
    axs[1, 2].set_ylabel("FRP [W/m^2]")
    axs[1, 2].set_xlabel("Calibration Temp [K]")
    axs[1, 2].legend()
    axs[2, 0].set_title("Sensor Temperature")
    axs[2, 0].set_xlabel("Calibration Temp [K]")
    axs[2, 0].set_ylabel("Sensor Temp [K]")
    axs[2, 0].legend()
    axs[2, 1].set_title("Predicted Target Temp Difference")
    axs[2, 1].set_xlabel("Calibration Temp [K]")
    axs[2, 1].set_ylabel("Predicted - Cal Temp [K]")
    axs[2, 1].legend()
    axs[2, 2].set_title("Predicted Target Temp")
    axs[2, 2].set_xlabel("Calibration Temp [K]")
    axs[2, 2].set_ylabel("Predicted Temp [K]")
    axs[2, 2].legend()

    plt.tight_layout()

    #################################
    # Save the calibration data
    #################################

    cal_time = datetime.datetime.now()
    cal_dict = {
        "cal_generation_dt": cal_time.isoformat(),
        "cal_input": str(cal_input_path.name),
        "temp_cal_input": str(temp_cal_input_path.name),
        "r_top": r_top,
        "v_top": v_top,
        "bands": {}
    }

    for band, band_data in bands_dict.items():
        cal_dict["bands"][band] = {
            "N": band_data["N"],
            "A": band_data["A"],
            "G": band_data["G"],
            "AL": band_data["AL"]
        }

    cal_dict["bands"]["WIDE"]["BandpassFraction"] = bands_dict["WIDE"]["BandpassFraction"]

    cal_results_output_path = cal_output_dir.joinpath(
        f'{cal_id}_UFM_{cal_time.isoformat().replace(":", "-")}.json')
    with open(cal_output_dir.joinpath(cal_results_output_path), 'w') as file:
        json.dump(cal_dict, file, indent=0)
    print("Saved calibration data to: ", cal_results_output_path)

    plot_path = cal_output_dir.joinpath(cal_results_output_path.stem + ".png")
    plt.savefig(plot_path)
    plt.show()
