import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import json
import shutil
import scipy.optimize as so
import scipy.constants as sc
import kremboxer.utils.greybody_utils as gbu
import datetime
import pandas as pd
from kremboxer.utils.common_utils import fit_detector_model, fit_kremens_detector_model

def compute_fiveband_calibration(cal_params: dict):
    """
    Computes model for retrieving radiance measurements from voltage readings generated by longwave, midwave, wide
    3.95, and 10.95um sensors on the fiveband devices

    Parameters
    ----------
    cal_params: dict
        "calibration_inputs_folder": folder containing the below calibration input data
        "LW_bandpass": bandpass for the longwave sensor, path to csv
        "MW_bandpass": bandpass for the midwave sensor, path to csv
        "WIDE_bandpass": bandpass for the wideband sensor, path to csv
        "3.95_bandpass": bandpass for the narrow 3.95um sensor, path to csv
        "10.95_bandpass": bandpass for the narrow 10.95um sensor, path to csv
        "cal_input": sensor values collected with a blackbody for calibration, path to csv
        "temp_cal_input": lookup table relating temperature to resistance of the temperature sensor inside the device, path to csv
        "v_top": voltage applied across the internal temperature sensor voltage divider
        "r_top": resistance of resistor in internal temperature sensor voltage divider
        "calibration_outputs_folder": folder to store the calibration results

    Returns
    -------
        None, calibration results are saved to file
    """

    print("Computing fiveband calibration with parameters: ", cal_params)

    # Grab input calibration data
    cal_input_dir = Path(cal_params["calibration_inputs_folder"])
    bands_dict = cal_params["bands"]
    cal_input_path = cal_input_dir.joinpath(cal_params["cal_input"])
    temp_cal_input_path = cal_input_dir.joinpath(cal_params["temp_cal_input"])
    v_top = cal_params["v_top"]
    r_top = cal_params["r_top"]

    # Where to store output calibration model
    cal_id = cal_params["calibration_id"]
    cal_output_dir = Path(cal_params["calibration_outputs_folder"]).joinpath(cal_id).joinpath("fiveband")
    cal_output_dir.mkdir(exist_ok=True, parents=True)

    # Copy input data into output directory so that we can easily match calibration models with input data
    shutil.copy(cal_input_path, cal_output_dir.joinpath(cal_input_path.name))
    cal_input_path = cal_output_dir.joinpath(cal_input_path.name)
    shutil.copy(temp_cal_input_path, cal_output_dir.joinpath(temp_cal_input_path.name))
    temp_cal_input_path = cal_output_dir.joinpath(temp_cal_input_path.name)

    # Load parameters needed to convert temperature sensor mV readings into resistance, using known voltage divider characteristics
    v_top = cal_params["v_top"]  # voltage at the top of divider in mV
    r_top = cal_params["r_top"]  # 100kOhm resistor in voltage divider
    t_cal_data = np.loadtxt(temp_cal_input_path, skiprows=1, delimiter=",", usecols=[0, 1, 2])
    t_cal_data = np.flip(t_cal_data, 0)

    # Load the blackbody calibration data and the target temperatures
    blackbody_cal_data_df = pd.read_csv(cal_input_path)
    t_actual = blackbody_cal_data_df["Target T [K]"].to_numpy()

    # Also copy and load bandpass into numpy arrays stored in the band dictionary
    for band, band_data in bands_dict.items():
        bandpass_path = Path(band_data["bandpass"])
        bandpass_copy_path = cal_output_dir.joinpath(bandpass_path.name)
        shutil.copy(bandpass_path, bandpass_copy_path)
        bands_dict[band]["bandpass"] = bandpass_copy_path
        f = np.loadtxt(bands_dict[band]["bandpass"], delimiter=',', skiprows=1, usecols=[0, 1])

        # Load temperature sensor data
        t_sensor_mV = blackbody_cal_data_df[band_data["sensor_temp"]].to_numpy()
        t_sensor_resist = t_sensor_mV * r_top / (v_top - t_sensor_mV)   # Convert mV reading into resistance of temperature sensor
        t_sensor_temp = gbu.detector_temperature_lookup(R=t_sensor_resist, temp_cal_data=t_cal_data)

        # Load the detector signal from the calibration data
        v = blackbody_cal_data_df[band_data["datalog_col"]].to_numpy()

        # Fit a polynomial for the blackbody energy received by each sensor, W~A*T**N
        (A, N, wd) = gbu.fit_received_bandpass_energy(f, t_actual)

        # Now fit the detector model with the calibration data to get G and AL
        #G, AL, pcov = fit_detector_model(t_actual, t_sensor_temp, v, A, N, p0=[band_data["G0"], band_data["AL0"]])
        G, pcov = fit_kremens_detector_model(t_actual, t_sensor_temp, v, A, N, p0=[band_data["G0"]])
        AL = A

        # Save the fit parameters and sensor data in the band dictionary
        bands_dict[band]["f"] = f
        bands_dict[band]["t_sensor_temp"] = t_sensor_temp
        bands_dict[band]["v"] = v
        bands_dict[band]["A"] = A
        bands_dict[band]["N"] = N
        bands_dict[band]["G"] = G
        bands_dict[band]["AL"] = AL
        bands_dict[band]["wd"] = wd
        bands_dict[band]["W_GB"] = bands_dict[band]["v"] / bands_dict[band]["G"] + bands_dict[band]["AL"] * bands_dict[band]["t_sensor_temp"] ** bands_dict[band]["N"]

        # Print the calibration values
        #print(f'{band}: N={N}, A={A}, G={G}, AL={AL}')
        print(f'band: {band}, A={A}, N={N}, G={G}, G*A={G * A}')

    ###############################################
    # End of calibration, now see how well the
    # computation of target temp reproduces the
    # known calibration data and make a big plot
    ###############################################
    lams = np.arange(0, 20, 0.05)
    fig, axs = plt.subplots(4, 3, figsize=(12, 15))

    # Plot blackbody curves for the calibration temperatures
    for T in t_actual:
        axs[0, 0].plot(lams, gbu.GB_lambda(lams*10**-6, T), label=f'{T}K')

    # Plot the individual band data
    for band, band_data in bands_dict.items():
        axs[1, 0].plot(band_data["f"][:, 0], band_data["f"][:, 1], label=band)
        plot_col = 1
        if not band_data["type"] == "broad":
            plot_col = 2
        axs[0, plot_col].scatter(t_actual, band_data["wd"], label=f'{band}, A={band_data["A"]:.3}, N={band_data["N"]:.2f}')
        axs[0, plot_col].plot(t_actual, gbu.planck_model(t_actual, band_data["A"], band_data["N"]), ls='--')
        axs[1, plot_col].scatter(t_actual, band_data["v"], label=f'{band}, G={band_data["G"]:.3}, AL={band_data["AL"]:.3}')
        axs[1, plot_col].plot(t_actual, gbu.detector_model(t_actual, band_data["G"], band_data["AL"], band_data["t_sensor_temp"], band_data["A"], band_data["N"]), ls='--')
        axs[0, plot_col].plot(t_actual, band_data["W_GB"], color='grey')
        axs[2, 0].plot(t_actual, band_data["t_sensor_temp"], label=f'{band}')

    # Try to predict target known temperatures, eA, FRP
    ratio_mw_lw = bands_dict["MW"]["W_GB"] / bands_dict["LW"]["W_GB"]
    ratio_mw_lw_narrow = bands_dict["3.95"]["W_GB"] / bands_dict["10.95"]["W_GB"]
    t_predict_mw_lw = np.zeros_like(t_actual)
    t_predict_mw_lw_narrow = np.zeros_like(t_actual)
    for i in range(0, len(t_actual)):
        t_predict_mw_lw[i] = so.brentq(lambda Ts: gbu.GB_ratio_BP(Ts, bands_dict["MW"]["f"], bands_dict["LW"]["f"]) - ratio_mw_lw[i], 300, 2000)
        try:
            t_predict_mw_lw_narrow[i] = so.brentq(lambda Ts: gbu.GB_ratio_BP(Ts, bands_dict["3.95"]["f"], bands_dict["10.95"]["f"]) - ratio_mw_lw_narrow[i], 300, 2000)
        except ValueError:
            print("Unable to predict temperature with 3.95 and 10.95 um bands for calibration temperature ", t_actual[i])
    axs[2, 1].plot(t_actual, t_predict_mw_lw-t_actual, label="MW/LW")
    axs[2, 1].plot(t_actual, t_predict_mw_lw_narrow-t_actual, label="3.95/10.95")
    axs[2, 2].plot(t_actual, t_predict_mw_lw, label="MW/LW")
    axs[2, 2].plot(t_actual, t_predict_mw_lw_narrow, label="3.95/10.95")
    axs[2, 2].plot(t_actual, t_actual, label="Actual")

    # Compute and plot emissivity area product and FRP
    eA_MW = bands_dict["MW"]["W_GB"] / gbu.planck_model(t_predict_mw_lw, bands_dict["MW"]["A"], bands_dict["MW"]["N"])
    FRP_MW = eA_MW * sc.Stefan_Boltzmann * t_predict_mw_lw ** 4
    eA_LW = bands_dict["LW"]["W_GB"] / gbu.planck_model(t_predict_mw_lw, bands_dict["LW"]["A"], bands_dict["LW"]["N"])
    FRP_LW = eA_LW * sc.Stefan_Boltzmann * t_predict_mw_lw ** 4
    eA_MW_narrow = bands_dict["3.95"]["W_GB"] / gbu.planck_model(t_predict_mw_lw_narrow, bands_dict["3.95"]["A"], bands_dict["3.95"]["N"])
    FRP_MW_narrow = eA_MW_narrow * sc.Stefan_Boltzmann * t_predict_mw_lw_narrow ** 4
    eA_LW_narrow = bands_dict["10.95"]["W_GB"] / gbu.planck_model(t_predict_mw_lw_narrow, bands_dict["10.95"]["A"], bands_dict["10.95"]["N"])
    FRP_LW_narrow = eA_LW_narrow * sc.Stefan_Boltzmann * t_predict_mw_lw_narrow ** 4

    axs[3, 0].plot(t_actual, eA_MW, label="MW")
    axs[3, 0].plot(t_actual, eA_LW, label="LW")
    axs[3, 0].plot(t_actual, eA_MW_narrow, label="3.95")
    axs[3, 0].plot(t_actual, eA_LW_narrow, label="10.95")
    axs[3, 0].set_title("Emissivity Area Product")
    axs[3, 0].set_xlabel("Calibration Temp [K]")
    axs[3, 0].set_ylabel("Emissivity*Area")
    axs[3, 0].legend()

    axs[3, 1].plot(t_actual, FRP_MW, label="MW")
    axs[3, 1].plot(t_actual, FRP_LW, label="LW")
    axs[3, 1].plot(t_actual, FRP_MW_narrow, label="3.95")
    axs[3, 1].plot(t_actual, FRP_LW_narrow, label="10.95")
    axs[3, 1].set_title("Fire Radiative Power")
    axs[3, 1].set_xlabel("Calibration Temp [K]")
    axs[3, 1].set_ylabel("FRP [W/m^2]")
    axs[3, 1].legend()

    # Debugging
    t_predict = np.zeros_like(t_actual)
    #axs[3, 1].plot(t_actual, ratio_mw_lw_narrow)
    Ts = np.arange(200, 1000, 10.0)
    GB_ratios = np.zeros_like(Ts)
    for i in range(0, len(Ts)):
        GB_ratios[i] = gbu.GB_ratio_BP(Ts[i], bands_dict["3.95"]["f"], bands_dict["10.95"]["f"])
    axs[3, 2].plot(Ts, GB_ratios, c='black', label="GB Ratio")
    for i in range(0, len(ratio_mw_lw_narrow)):
        axs[3, 2].axhline(y=ratio_mw_lw_narrow[i], ls='--', label=f'T={t_actual[i]}K')
    axs[3, 2].legend()
    axs[3, 2].set_title("Ratio of Blackboy Irradiances 3.95/10.95")
    axs[3, 2].set_xlabel("Blackbody Temperature [K]")
    axs[3, 2].set_ylabel("Irradiance Ratio")

    axs[0, 0].set_title("Planck Radiance at Cal Temps")
    axs[0, 0].set_xlabel("Wavelength [um]")
    axs[0, 0].set_ylabel("Radiance [W/m^2*um]")
    axs[0, 0].legend()
    axs[1, 0].set_title("Bandpasses")
    axs[1, 0].set_xlabel("Wavelength [um]")
    axs[1, 0].set_ylabel("Transmission")
    axs[1, 0].legend()
    axs[0, 1].set_title("Blackbody Irradiance")
    axs[0, 1].set_xlabel("Calibration Temp [K]")
    axs[0, 1].set_ylabel("Irradiance [W/m^2]")
    axs[0, 1].legend()
    axs[0, 2].set_title("Blackbody Irradiance")
    axs[0, 2].set_xlabel("Calibration Temp [K]")
    axs[0, 2].set_ylabel("Irradiance [W/m^2]")
    axs[0, 2].legend()
    axs[1, 1].set_title("Sensor Signal")
    axs[1, 1].set_xlabel("Calibration Temp [K]")
    axs[1, 1].set_ylabel("Voltage [mV]")
    axs[1, 1].legend()
    axs[1, 2].set_title("Sensor Signal")
    axs[1, 2].set_xlabel("Calibration Temp [K]")
    axs[1, 2].set_ylabel("Voltage [mV]")
    axs[1, 2].legend()
    axs[2, 0].set_title("Sensor Temperature")
    axs[2, 0].set_xlabel("Calibration Temp [K]")
    axs[2, 0].set_ylabel("Sensor Temp [K]")
    axs[2, 0].legend()
    axs[2, 1].set_title("Predicted Target Temp Difference")
    axs[2, 1].set_xlabel("Calibration Temp [K]")
    axs[2, 1].set_ylabel("Predicted - Cal Temp [K]")
    axs[2, 1].legend()
    axs[2, 2].set_title("Predicted Target Temp")
    axs[2, 2].set_xlabel("Calibration Temp [K]")
    axs[2, 2].set_ylabel("Predicted Temp [K]")
    axs[2, 2].legend()

    plt.tight_layout()

    #################################
    # Save the calibration data
    #################################

    cal_time = datetime.datetime.now()
    cal_dict = {
        "cal_generation_dt": cal_time.isoformat(),
        "cal_input": str(cal_input_path.name),
        "temp_cal_input": str(temp_cal_input_path.name),
        "r_top": r_top,
        "v_top": v_top,
        "bands": {}
    }

    for band, band_data in bands_dict.items():
        cal_dict["bands"][band] = {
            "N": band_data["N"],
            "A": band_data["A"],
            "G": band_data["G"],
            "AL": band_data["AL"],
            "bandpass": str(band_data["bandpass"].name)
        }

    cal_results_output_path = cal_output_dir.joinpath(
        f'{cal_id}_Fiveband_{cal_time.isoformat().replace(":", "-")}.json')
    with open(cal_output_dir.joinpath(cal_results_output_path), 'w') as file:
        json.dump(cal_dict, file, indent=0)
    print("Saved calibration data to: ", cal_results_output_path)

    plot_path = cal_output_dir.joinpath(cal_results_output_path.stem+".png")
    plt.savefig(plot_path)
    plt.show()
